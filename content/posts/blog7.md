---
title: "Blog #7 | Transitioning to C++"
date: 2024-11-03T19:13:54-05:00
draft: false
tags: ["blogs"]
---

Happy Sunday!

It's been a while since I wrote my last blog post. As much as I'd like to talk about all the great things I've done while I’ve been gone, the reality is that the last two weeks haven't really been that great, to be honest. In fact, It’s been quite stressful and full of bad choices, but that is fine since I have learned from my mistakes.

The most recent assignment given to us in our Operating Systems course has pretty much destroyed whatever love I had for C. I have been trying to recreate the assignment in C++ in the last two days and so far it's been a much better experience trying to write code that is more efficient and maintainable. At this point, I'm just angry at myself for never using it sooner. There is of course a bit of a learning curve transitioning from C to C++, but what little I have implemented has managed to impress me quite a lot.  

Our final assignment makes us use all of the concepts we have learned so far to implement a program that simulates a [process scheduler](https://en.wikipedia.org/wiki/Scheduling_(computing)) which simply prints a certain output in a certain order based on the type of given input. In layman's terms, you can think of a scheduler as a traffic policeman who stands at an intersection and manages the flow of traffic to prevent congestion and maintain order. Depending on several factors, he decides which lane has more priority and is allowed to drive, and which lane doesn't. 

In the example of an operating system, the scheduler simply does the same job to decide which process is allowed to run and for how long before it must be interrupted to allow another process to run. Depending on how one may design their scheduler, there may simply be no interrupts and a process can be allowed to run to completion. There are various ways to implement a scheduler that can perform its tasks in different ways.

I'm considering implementing this assignment in C++, and I'd love to talk about it once I complete it. This course has really made me appreciate low-level programming and how computers are built and work at their most fundamental level. I believe information like this can definitely help someone write more efficient code for large projects to improve overall system performance, and I'm really grateful I have access to this information considering how rare it can be to obtain, especially if someone is teaching themselves all of this stuff. 

As always, I'm excited to welcome this new week and hope to continue learning new things!